#include <stdint.h>
#include "LCD.h"
#include "GC9A01A.h"

typedef struct CHAR_INFO {
  uint8_t* buffer;
  uint8_t width;
  uint8_t height;
  uint8_t x_offset;
  uint8_t y_offset;
  uint8_t max_column;
  uint8_t max_row;
} CHAR_INFO;

static char char_extra_small_buffer[7 * 8 * 2];      // 7x8   pixels (1 pixel -> 1x1) -> 34 column, 30 row, 1 x_off, 0 y_off
static char char_small_buffer[7 * 8 * 2 * 4];        // 14x16 pixels (1 pixel -> 2x2) -> 17 column, 15 row, 1 x_off, 0 y_off
static char char_medium_buffer[7 * 8 * 2 * 9];       // 21x24 pixels (1 pixel -> 3x3) -> 11 column, 10 row, 4 x_off, 0 y_off            
static char char_large_buffer[7 * 8 * 2 * 16];       // 28x32 pixels (1 pixel -> 4x4) ->  8 column,  7 row, 8 x_off, 8 y_off
static char char_extra_large_buffer[7 * 8 * 2 * 25]; // 35x40 pixels (1 pixel -> 5x5) ->  6 column,  6 row, 15 x_off, 0 y_off
static char char_title_buffer[7 * 8 * 2 * 36];       // 42x48 pixels (1 pixel -> 6x6) ->  5 column,  5 row, 15 x_off, 0 y_off

static CHAR_INFO chars[6] = {
  {
    .buffer     = char_extra_small_buffer,
    .width      = 7,
    .height     = 8,
    .x_offset   = 1,
    .y_offset   = 0,
    .max_column = 34,
    .max_row    = 30
  },
  {
    .buffer     = char_small_buffer,
    .width      = 14,
    .height     = 16,
    .x_offset   = 1,
    .y_offset   = 0,
    .max_column = 17,
    .max_row    = 15
  },
  {
    .buffer     = char_medium_buffer,
    .width      = 21,
    .height     = 24,
    .x_offset   = 4,
    .y_offset   = 0,
    .max_column = 11,
    .max_row    = 10
  },
  {
    .buffer     = char_large_buffer,
    .width      = 28,
    .height     = 32,
    .x_offset   = 8,
    .y_offset   = 8,
    .max_column = 8,
    .max_row    = 7
  },
  {
    .buffer     = char_extra_large_buffer,
    .width      = 35,
    .height     = 40,
    .x_offset   = 15,
    .y_offset   = 0,
    .max_column = 6,
    .max_row    = 6
  },
  {
    .buffer     = char_title_buffer,
    .width      = 42,
    .height     = 48,
    .x_offset   = 15,
    .y_offset   = 0,
    .max_column = 5,
    .max_row    = 5
  }
};

// Just use ASCII table references - ' ' as it starts at the space character
// This font is renew, homespun isn't bad and Minimum+1 has its colors inverted
const char font[96][7] = {
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //  
	{0x5e,0x00,0x00,0x00,0x00,0x00,0x00}, // !
	{0x0c,0x00,0x0c,0x00,0x00,0x00,0x00}, // "
	{0x14,0x3e,0x14,0x3e,0x14,0x00,0x00}, // #
	{0x2e,0x2a,0x7f,0x2a,0x3a,0x00,0x00}, // $
	{0x1c,0x14,0x1c,0x00,0x7c,0x00,0x70}, // %
	{0x78,0x4e,0x5a,0x2e,0x40,0x00,0x00}, // &
	{0x0c,0x00,0x00,0x00,0x00,0x00,0x00}, // '
	{0x7e,0x81,0x00,0x00,0x00,0x00,0x00}, // (
	{0x81,0x7e,0x00,0x00,0x00,0x00,0x00}, // )
	{0x04,0x1c,0x0e,0x1c,0x04,0x00,0x00}, // *
	{0x08,0x1c,0x08,0x00,0x00,0x00,0x00}, // +
	{0xc0,0x00,0x00,0x00,0x00,0x00,0x00}, // ,
	{0x08,0x08,0x08,0x00,0x00,0x00,0x00}, // -
	{0x40,0x00,0x00,0x00,0x00,0x00,0x00}, // .
	{0x70,0x0e,0x00,0x00,0x00,0x00,0x00}, // /
	{0x7c,0x44,0x7c,0x00,0x00,0x00,0x00}, // 0
	{0x08,0x7c,0x00,0x00,0x00,0x00,0x00}, // 1
	{0x64,0x54,0x4c,0x00,0x00,0x00,0x00}, // 2
	{0x44,0x54,0x7c,0x00,0x00,0x00,0x00}, // 3
	{0x1c,0x10,0x7c,0x00,0x00,0x00,0x00}, // 4
	{0x5c,0x54,0x34,0x00,0x00,0x00,0x00}, // 5
	{0x7c,0x54,0x74,0x00,0x00,0x00,0x00}, // 6
	{0x04,0x04,0x7c,0x00,0x00,0x00,0x00}, // 7
	{0x7c,0x54,0x7c,0x00,0x00,0x00,0x00}, // 8
	{0x1c,0x14,0x7c,0x00,0x00,0x00,0x00}, // 9
	{0x50,0x00,0x00,0x00,0x00,0x00,0x00}, // :
	{0xd0,0x00,0x00,0x00,0x00,0x00,0x00}, // ;
	{0x20,0x50,0x50,0x00,0x00,0x00,0x00}, // <
	{0x28,0x28,0x28,0x00,0x00,0x00,0x00}, // =
	{0x50,0x50,0x20,0x00,0x00,0x00,0x00}, // >
	{0x02,0x5a,0x0e,0x00,0x00,0x00,0x00}, // ?
	{0x7e,0x42,0x5a,0x5a,0x52,0x5e,0x00}, // @
	{0x7e,0x0a,0x0a,0x7e,0x00,0x00,0x00}, // A
	{0x7e,0x4a,0x4a,0x7c,0x00,0x00,0x00}, // B
	{0x7e,0x42,0x42,0x42,0x00,0x00,0x00}, // C
	{0x7e,0x42,0x42,0x7c,0x00,0x00,0x00}, // D
	{0x7e,0x4a,0x4a,0x42,0x00,0x00,0x00}, // E
	{0x7e,0x0a,0x0a,0x02,0x00,0x00,0x00}, // F
	{0x7e,0x42,0x4a,0x7a,0x00,0x00,0x00}, // G
	{0x7e,0x08,0x08,0x7e,0x00,0x00,0x00}, // H
	{0x42,0x42,0x7e,0x42,0x42,0x00,0x00}, // I
	{0x42,0x42,0x7e,0x02,0x00,0x00,0x00}, // J
	{0x7e,0x08,0x0e,0x78,0x00,0x00,0x00}, // K
	{0x7e,0x40,0x40,0x40,0x00,0x00,0x00}, // L
	{0x7e,0x02,0x06,0x02,0x7e,0x00,0x00}, // M
	{0x7e,0x04,0x08,0x7e,0x00,0x00,0x00}, // N
	{0x7e,0x42,0x42,0x7e,0x00,0x00,0x00}, // O
	{0x7e,0x0a,0x0a,0x0e,0x00,0x00,0x00}, // P
	{0x7e,0x42,0xc2,0x7e,0x00,0x00,0x00}, // Q
	{0x7e,0x0a,0x7a,0x0e,0x00,0x00,0x00}, // R
	{0x4e,0x4a,0x4a,0x7a,0x00,0x00,0x00}, // S
	{0x02,0x02,0x7e,0x02,0x02,0x00,0x00}, // T
	{0x7e,0x40,0x40,0x7e,0x00,0x00,0x00}, // U
	{0x1e,0x20,0x40,0x20,0x1e,0x00,0x00}, // V
	{0x7e,0x40,0x60,0x40,0x7e,0x00,0x00}, // W
	{0x42,0x24,0x18,0x24,0x42,0x00,0x00}, // X
	{0x0e,0x08,0x78,0x08,0x0e,0x00,0x00}, // Y
	{0x62,0x52,0x4a,0x46,0x00,0x00,0x00}, // Z
	{0xff,0x81,0x00,0x00,0x00,0x00,0x00}, // [
	{0x0e,0x70,0x00,0x00,0x00,0x00,0x00}, // "\"
	{0x81,0xff,0x00,0x00,0x00,0x00,0x00}, // ]
	{0x04,0x02,0x04,0x00,0x00,0x00,0x00}, // ^
	{0x40,0x40,0x40,0x40,0x40,0x00,0x00}, // _
	{0x02,0x04,0x00,0x00,0x00,0x00,0x00}, // `
	{0x7c,0x14,0x14,0x7c,0x00,0x00,0x00}, // a
	{0x7c,0x54,0x54,0x78,0x00,0x00,0x00}, // b
	{0x7c,0x44,0x44,0x44,0x00,0x00,0x00}, // c
	{0x7c,0x44,0x44,0x78,0x00,0x00,0x00}, // d
	{0x7c,0x54,0x54,0x44,0x00,0x00,0x00}, // e
	{0x7c,0x14,0x14,0x04,0x00,0x00,0x00}, // f
	{0x7c,0x44,0x54,0x74,0x00,0x00,0x00}, // g
	{0x7c,0x10,0x10,0x7c,0x00,0x00,0x00}, // h
	{0x44,0x44,0x7c,0x44,0x44,0x00,0x00}, // i
	{0x44,0x44,0x7c,0x04,0x00,0x00,0x00}, // j
	{0x7c,0x10,0x1c,0x70,0x00,0x00,0x00}, // k
	{0x7c,0x40,0x40,0x40,0x00,0x00,0x00}, // l
	{0x7c,0x04,0x0c,0x04,0x7c,0x00,0x00}, // m
	{0x7c,0x08,0x10,0x7c,0x00,0x00,0x00}, // n
	{0x7c,0x44,0x44,0x7c,0x00,0x00,0x00}, // o
	{0x7c,0x14,0x14,0x1c,0x00,0x00,0x00}, // p
	{0x7c,0x44,0xc4,0x7c,0x00,0x00,0x00}, // q
	{0x7c,0x14,0x74,0x1c,0x00,0x00,0x00}, // r
	{0x5c,0x54,0x54,0x74,0x00,0x00,0x00}, // s
	{0x04,0x04,0x7c,0x04,0x04,0x00,0x00}, // t
	{0x7c,0x40,0x40,0x7c,0x00,0x00,0x00}, // u
	{0x1c,0x20,0x40,0x20,0x1c,0x00,0x00}, // v
	{0x7c,0x40,0x60,0x40,0x7c,0x00,0x00}, // w
	{0x44,0x28,0x10,0x28,0x44,0x00,0x00}, // x
	{0x1c,0x10,0x70,0x10,0x1c,0x00,0x00}, // y
	{0x64,0x54,0x4c,0x44,0x00,0x00,0x00}, // z
	{0x08,0xf7,0x81,0x00,0x00,0x00,0x00}, // {
	{0xff,0x00,0x00,0x00,0x00,0x00,0x00}, // |
	{0x81,0xf7,0x08,0x00,0x00,0x00,0x00}, // }
	{0x18,0x08,0x10,0x18,0x00,0x00,0x00}, // ~
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00}
};

static uint8_t map(uint8_t x, uint8_t in_min, uint8_t in_max, uint8_t out_min, uint8_t out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void lcd_write_char(char character, uint8_t x, uint8_t y, LCD_CHAR_SIZE size, uint8_t red, uint8_t green, uint8_t blue)
{
  CHAR_INFO tmp_char = chars[size - 1]; // Size is enumerated starting at 1

  uint16_t color = lcd_RGB(red, green, blue);

  // First create the base image
  uint16_t charArrayIndex = 0;
  for (int i = 0; i < 8; i++){
      for (int j = 0; j < 7; j++){
          if (font[character - ' '][j] & (1<<i)) {
              char_extra_small_buffer[charArrayIndex++] = color >> 8;
              char_extra_small_buffer[charArrayIndex++] = color;
          } else {
              char_extra_small_buffer[charArrayIndex++] = 0x00;
              char_extra_small_buffer[charArrayIndex++] = 0x00;
          }
      }
  }

  if (size > 1){
    charArrayIndex = 0;
    uint16_t bigCharArrayIndex = 0;
    for (int i = 0; i < 8; i++){ // For every original row
      for (int j = 0; j < size; j++){ // Repeat that row scale_factor number of times
        charArrayIndex = i * 7 * 2; // Reset index to start of current row to print again
        for (int k = 0; k < 7; k++){ // Print every pixel column
            for (int l = 0; l < size; l++){ // Repeat same pixel scale_factor number of times
                tmp_char.buffer[bigCharArrayIndex++] = char_extra_small_buffer[charArrayIndex++]; // Write first pixel and increment
                tmp_char.buffer[bigCharArrayIndex++] = char_extra_small_buffer[charArrayIndex--]; // Write second pixel and decrement back to first pixel
            }
            charArrayIndex+=2; // Increment original pointer to the next pixel
        }
      }
    }
  }  

  // Set row and column for character
  GC9A01A_set_position(x, x + tmp_char.width - 1, y, y + tmp_char.height - 1);

  // Write character
  GC9A01A_write(tmp_char.buffer, tmp_char.width * tmp_char.height * 2);
    
}

void lcd_write_str(char* string, uint8_t x, uint8_t y, LCD_CHAR_SIZE size, uint8_t red, uint8_t green, uint8_t blue)
{
  CHAR_INFO tmp_char = chars[size - 1]; // Size is enumerated starting at 1
  int i = 0;
  while (string[i] != '\0')
  {
    lcd_write_char(string[i], x + (i * tmp_char.width), y, size, red, green, blue);
    i++;
  }
}

// Place a character at a specific location based on a row and column scheme dependent on the size of the character
void lcd_write_char_grid(char character, uint8_t row, uint8_t column, LCD_CHAR_SIZE size, uint8_t red, uint8_t green, uint8_t blue)
{
  CHAR_INFO tmp_char = chars[size - 1]; // Size is enumerated starting at 1 
  lcd_write_char(character, tmp_char.x_offset + (column * tmp_char.width), tmp_char.y_offset + (row * tmp_char.height), size, red, green, blue);
}

// Print a string to the LCD starting at the specified row and column. This function will wrap the text if the end of the row is reached.
void lcd_write_str_grid(char* string, uint8_t row, uint8_t column, LCD_CHAR_SIZE size, uint8_t red, uint8_t green, uint8_t blue)
{
  CHAR_INFO tmp_char = chars[size - 1]; // Size is enumerated starting at 1 
  if (row > tmp_char.max_row || column > tmp_char.max_column)
  {
    return;
  }

  // Write characters while rolling over the column values
  // If the word will not all fit on the line it will also wrap the word
  int i = 0;
  while (string[i] != '\0')
  {
    if (string[i] == ' '){
      int j = i + 1;
      while (string[j] != ' ' && string[j] != '\0') j++;

      // Once the word is parsed its length will be from i+1->j-1 or (j - i - 1)
      // Only wrap the word if its total length is:
      //    less than or equal to the maximum column length, otherwise it'll have to wrap no matter what
      //    and if written normally it would surpass the column maximum
      if ((j - i - 1) <= tmp_char.max_column && (column + (j - i - 1)) >= tmp_char.max_column)
      {
        column = 0;
        row++;
        i++; // Increment i so that the space character is not printed
      }
    }

    if (column >= tmp_char.max_column) // >= because it is zero indexed
    {
      column = 0;
      row++;
    }

    if (row >= tmp_char.max_row) // >= because it is zero indexed
    {
      // There is no more space to write to on the screen
      return;
    }

    lcd_write_char_grid(string[i], row, column, size, red, green, blue);
    column++;
    i++;
  }

  return;
}

void lcd_draw_bitmap(uint8_t* bitmap, uint8_t width, uint8_t height, uint8_t x, uint8_t y)
{
  if (width > 240 || height > 240 || x > 240 || x > 240 || bitmap == NULL) return;
  // It will be assumed that the bitmap memory is already in 5-6-5 RGB format
  // It will also be assumed that the buffer provided is of the proper size
  
  // Position screen cursor to the provided x and y
  GC9A01A_set_position(x, x + width - 1, y, y + height - 1);

  // Write the provided bitmap data
  GC9A01A_write(bitmap, width * height * 2);
}

void lcd_fill(uint8_t red, uint8_t green, uint8_t blue)
{
  GC9A01A_fill_screen(lcd_RGB(red, green, blue));
}

void lcd_clear(void)
{
  // As there is no clear screen command this is the best we can do, avoid using
  lcd_fill(0, 0, 0);
}

